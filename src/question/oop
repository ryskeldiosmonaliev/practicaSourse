 /**# Что такое объектно-ориентированное программирование (ООП)?
     # Что такое класс и объект?
     Класс болот жана ал класстын
     объектилери болот. Анан ошол объект
     функцияларды аткарат
     # Что делать, если поля в классе?
     Переменныйлары болот (поле деп
     атасаныздар болот(англисче field
     болот))
     # Что такое конструктор? Зачем нам это нужно?
     Конструктор — это специальный метод, который вызывается при создании
     нового объекта (всегда вызывается совместно с операцией new).
     Конструктор нужен для автоматической инициализации переменных,
     т.е. он инициализирует объект непосредственно во время создания
     # Какие есть типы конструктора?
     Конструктор по умолчанию (default constructor)
     Конструктор без параметра (no arg constructor)
     Конструктор с параметром (parameterized constructor
     # Можем ли мы создать объект без конструктора?
     Конструктор тузуло элек объект тузгондо,
     жава озу конструктор тузот. Эгерде биз
     конструкторду тузгон болсок, анда
     конструктор по умолчанию тузулбойт.
     # Что такое инкапсуляция?
     Жавада объекттердин(класстардын) полелерин жана методторун
     капсулага салса болот.
     эмнеге капсулага салабыз?
     Кандайдыр бир объекттин полесине туура эмес маалымат
     берилбеши учун.
     Мисалы: студентке жашыны 220 деп берген туура эмес.
     # Почему мы используем геттеры и сеттеры?
     АНДА КАНТИП КОЛДОНОБУЗ АЛ
     ПОЛЕЛЕРДИ ЖЕ МЕТОДТОРДУ?
     Ал полелерди алуу учун, алып
     беруучу метод керек. (getter)
     АЛ ПОЛЕЛЕРГЕ КАНТИП МААНИ
     БЕРЕБИЗ?
     Ал полелерге маани беруу учун
     маани беруучу метод тузобуз. (setter)
     GETTER
     Маанини алып беруучу метод.
     Кайсы полени алышыныз
     керек болуп жатса ошол
     поленин атына "get" созун
     кошо жазып метод тузуу керек.
     Мисалы: getName(); getAge();
     SETTER
     Маани орнотуучу метод.
     Маанини кайсы полеге
     орноткунуз келсе ошол
     поленин атына "set" созун
     кошуп метод тузосуз.
     Мисалы: setColor(); setHeight()
     # Что является приватным?
     Биз полелерди же методторду private
     модификатору менен коргоого алсак
     болот.
     Private класстын сыртында
     корунбойт дегенди билдирет.
     Эгерде биздин методубуз же
     полебиз privat болсо анда биз аны
     класстын ичинде гана колдоно
     алабыз
     # Что такое наследование?
     Мурастоо(наследование)
     Мурастоо бул бир класстын мумкунчулугун кобойтуу же
     болбосом класстардын бири бирине болгон мамилеле.
     Эмнеге мурастоо керек? кодубузду кыскартуу жана
     класстардын мамилесин тузуу учун.

     # Какие бывают типы наследования?
     Мурасталып жаткан классты "parent class" дейбиз.
     Parent класста канча поле же метод болбосун баары child класска
     жеткиликтуу болот
     Мурастап жаткан классты "child class" дейбиз

     # Что такое «расширяет»?
     Ключевое слово extends означает,
     что на основе существующего класса создается новый класс.
     # Что такое ключевые слова «это» и «супер»?
     this представляет текущий экземпляр класса,
     в то время как super - текущий экземпляр родительского класса
     Мурастаганда конструкторду да мурастоо керек.
     Мисалда биз parent класстын конструкторун "super"
     сыйкыр созу аркылуу чакырып жатабыз
     # Что такое пакеты?
     Пакеттерди, папкалар
     деп тушунсонуздор
     болот
     Пакеттер кандай койгойлорду чечет?
     Биз жавада бир жерде эки окшош аттуу
     класс тузо албайбыз, бирок пакеттер бул
     койгойду чечет
     # Почему мы используем метод toString()?
     toString();
     Биз консолго объекттин чыгарганда ошол объект жонундо
     маалыматтарды коргубуз келсе биз toString(); колдонобуз.
     toString(); бул жонокой эле String кайтарган метод
     # Расскажите мне о модификаторах доступа
     Бул сыйкыр создорду
     кайсыл жерлерде
     колдонсок болот?
     Класстарда
     Полелерде
     Конструкторлордо
     Методтордо
     # Какая разница между модификаторами Protected и Default
     public
     Эгерде модификаторду полеге
     колдонсонуз, анда ал поле бардык жерде
     корунот
     protected
     Эгерде бул модификаторду полеге
     колдонсонуз анда ал поле пакеттин
     ичинде коруно берет жана башка
     пакеттеги child класстарына корунот
     default
     protectedке окшош бирок пакеттин
     сыртындагы child класстарга корунбойт
     private
     Kласстын ичинде гана корунот
     # Можем ли мы создать статический и окончательный класс?
     Модификатор
     final
     Кээ бир класс, поле же методтун
     озгорулбошун кааласаныз, анда
     final модификаторун
     колдоносуз.
     final class{}
     Класска колдонсо болот
     Классты final кылсаныз анда ал классты эч кайсы
     класс мурастай албай калат.

     final int a;
     Полелерге колдонсо болот
     Полени final кылсаныз анда ал полеге бир жана
     акыркы жолу маани бере аласыз башкача
     айтканда поле константа болуп калат.

     final void
     method() {}
     Методторго колдонсонуз болот
     Методту final кылсаныз ал методту owerride кыла
     албайсыз.

     Модификатор
     static
     Эгерде сиздер методторго же
     полелерге бат доступ алууну
     кааласаныз, анда static
     модификаторун колдоносуз

     static int a
     Полеге колдонсонуз болот
     Полени static кылсаныз анда ал полеге доступту класстын
     аты менен алсаныз боло

     static void
     method() {}
     static class{}
     Методко колдонсонуз болот
     Полени static кылсаныз анда ал полеге доступту класстын
     аты менен алсаныз болот
     Методту static кылсаныз анда ал методко да класстын аты
     менен доступ алсаныз болот.

     static class{}
     класска колдонсок болот
     класска дегенде бир гана вложеный класстарды static кыла аласыз Жонокой классты static кылганга болбойт
     # Что происходит, когда мы используем ключевые слова static и final для классов, полей, методов? +
     static  ди койсок анда ал клсска байланып калат жана класстын аты аркылуу чакырып алсак болот
     final ды колдонсок ал константа болуп калат б.а озгорто албайбыз
     # Что такое полиморфизм?
     Полиморфизм
     деген эмне? Полиморфизм деген
     формалары коп дегенди
     билдирет.
     Биз бир кодту коп турлору менен жазсак болот,
     башкача айтканда объектилерди коп форма
     менен тузсок болот жана методторду да ар
     кандай формаларын тузсок боло

     Полиморфизм эмнеге керек?
     Полиморфизм абстракцияны ишке ашырууда
     жардам берет жана бир типтеги объектилерди
     чогултууга мумкунчулук жаратат.
     Полиморфизм ООПнын башка принциптери
     менен тыгыз байланышта. Мурастоо жок болсо
     полиморфизмди реализация кыла албайбыз.
     Ар бир класс полиморфный болуп саналат
     эмнеге дегенде класстардын баары Objectти
     мурастайт
     # Что такое методы @Overriding и Overloading?
     @Override
     Ушундай аннотацияны жазуу
     керек override кылганда.

     Override бул parent класстагы методту
     child класста башка формада жазуу.
     Мисалда voice методу эки башка
     реализация менен жазылган.
     Орусча переопределение деп айтат

     Overload
     Методко overload деп жазуунун
     кереги жок, бул аннотация эмес
     Overload орусчасы перегрузка деп аталат.
     Overload бул бир методту ар кандай формада тузуу,
     параметрлери ар кандай болуусу керек.
     Мурун аттары окшош методторду тузуу мумкун эмес
     деп билчук бирок тузсок болот.(параметрлери
     озгочолонуп турса)
     # Что такое абстракция в java?

     # Какая разница между простым классом и абстрактным классом

     # Что такое абстрактный класс?
     Эгерде класс abstract
     деген модификатор
     менен белгиленген
     болсо анда биз анын
     объектисин тузо
     албайбыз.
     # Можем ли мы создать объект абстрактного класса в java?

     # Зачем нам нужен конструктор внутри абстрактного класса? ?
     Классты abstract деп белгилеп коюп биз анын объектисин тузууго тыюу
     салып койдук, анын наследник класстарынын объектиси тузулсун,
     конкреттуу жаныбарлар болсун деп
     # Что такое абстрактные методы?
     метод abstract деген модификатор менен белгилениши керек
     abstract деген модификатор менен белгиленген методдун реализациясы
     болбойт

     # Что такое интерфейс?
     Интерфейс
     Абстракцияны ишке ашыруучулар абстракт
     класстар жана интерфейстер болуп саналат.
     Интерфейс абстракт класстарга окшош объект
     тузгонго жол бербейт.
     Бирок интерфейстер коп жолу мурастоого жол
     берет (бул интерфейстин эн чон плюстарынын
     бири).
     Интерфейс бул класс менен болгон контракт

     # Что такое ключевое слово «implements»?
     Абстракт классты
     Мусрастоо учун extends сыйкыр созун
     колдонобуз.
     Интерфейсти
     Мурастоо учун implements сыйкыр
     созун колдонобу

     # Можем ли мы создать объект интерфейса?
     Экземпляр интерфейса сделать нельзя. И это не нужно.
     В интерфейсе прописаны (причем без тела, только сигнатурами)
     методы, которые должны быть в таких классах,
     которые реализуют (implements) данный интерфейс.
     Интерфейс - это контракт,
     "обязательство". Методы в нем не выписываются.
     Поэтому логично, что экземпляров ему не надо
     # Как мы можем создать метод с телом внутри интерфейса?
     defaul
     # Можем ли мы определить поля внутри интерфейса?
     Абстрактный класс наследуется (extends), а интерфейс — реализуется (implements).
     Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно.
     Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
     Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник
     расширяет базовый абстрактный класс,
     а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
     # Какая разница между интерфейсом и абстрактным классом
     # Может ли абстрактный класс реализовать интерфейс?
     # Может ли интерфейс расширять абстрактный класс?
     №3/3
     # Что такое  Enum ?
     это набор именованных констант,
     который помогает в определении своих собственных типов данных.
     Когда вы можете определить тип переменных в программе,
     становится легко их определить.
     Перечисление — это в основном список именованных констант.
     Enumда константалар чон тамга менен жазылат.
     Жонокой полелерди жана методторду да тузсо
     болот.
     Конструктору приватный болот.


     # Какие на самом деле константы в enum?
     Ар бир константасы объект
     # Какие методы есть в классе enum?
     Enumда абстрактный метод тузсо болот
     Enum methods
     Биз тузгон енамдардын баары по умолчанию абстарктный класс Enum ды мурастайт.
     ordinal();
     Константа канчанчы орунда турат
     экенин кайтарып берет, орундар 0дон
     башталат.

     values();
     Бут константаларды массивге
     салып кайтарып берет.

     valueOf();
     Созго карата константа кайтарып
     берет.
     name();
     Константанын строковый маанисин
     кайтарып берет.

     toString();
     Константанын атын кайтарып берет

     # Почему модификатор доступа конструктора enum по умолчанию приватный?
     Думайте о Enums как о классе с конечным числом экземпляров.
     Никогда не может быть других экземпляров, кроме тех, которые вы изначально объявили.

     Таким образом, у вас не может быть общедоступного или защищенного конструктора,
     потому что это позволит создать больше экземпляров.
     # Зачем нужна обработка исключений?
     При обработке исключений в Java применяются следующие ключевые слова :
     — try – служит для определения блока кода, в котором может произойти исключение;
     — catch – необходим для определения блока кода, где происходит обработка исключения;
     — finally – применяется для определения блока кода, являющегося необязательным,
     однако при его наличии он выполняется в любом случае вне зависимости от результата выполнения блока try.
     # Что такое Try с ресурсами?
     # Что означает проверенное и непроверенное исключение?
     # Зачем нам нужно ключевое слово throws?
     Бул сыйкыр соз менен биз эскертуу беребиз.
     Методтун сигнатурасына жазылат.
     Бул методто кандайдыр бир run-time exception чыгышы мумкун деген
     эскертуу берет
     # Можем ли мы обработать ошибку?
     # Что содержит каркас коллекции?
     # Какие интерфейсы расширяют интерфейс Collection?
     Интерфейс Collection Позволяет работать с группами объектов;
     находится на вершине иерархии коллекций.
     2. Интерфейс List Расширяет Collection и экземпляр List хранит упорядоченный набор элементов.
     3. Интерфейс Set Расширяет Collection, чтобы обрабатывать наборы, которые должны содержать уникальные элементы.
     # Как работает ArrayList?
     Динамический массив деп аталат, эмнеге дегенде биз бул
     массивдин размерин бербейбиз, озу чонойуп кичирейет.
     Бул коп методтору бар класс.
     Объектисин тузуп, ичине методтору аркылуу
     маалыматтарды салсак болот.
     ArrayList тип катары бир гана ссылочный типтерди кабыл
     алат.
     ARRAYLIST


     # Как работает LinkedList?
     # Какая разница между ArrayList и LinkedList?
     ArrayList - это список на основе массива.
     LinkedList - связанный список на основе элементов и связи между ними.
     # В чем особенность интерфейса Set?
     HashSet озуно уникалдуу гана
     маанилерди сактайт,
     кайталанууга жол бербейт.
     (хранит значуние Map)

     # Есть ли индексы в интерфейсе Set?
     Маанилерди бергенде HashSet
     ирети жок сактайт, ошого
     HashSetте get(); методу жок
     # В чем разница между HashSet LinkedHashSet и TreeSet?
     hasset как хочетж
     linkedHassed биз киргизгендей чыгаратж
     Treeset вводит по возрастанию
     # Что означает методы equals hashCode и откуда они взялись?
     EQUALS();
     HASHCODE();
     OBJECT КЛАССЫНЫН МЕТОДТОРУ.

     equals();
     Oбъекттин тибин жана полелерин
     бирибирине салыштыруу учун керек.

     hashCode();
     Полелеринин HashCodeторунун суммасын
     табат.


     # Почему Map не расширяет интерфейс Коллекции?
     Map – пара ключ/значение,
     тогда как Collection представляет собой набор группы объектов,
     хранящихся в структурированном виде, и имеет определенный механизм доступа.
     Причина, по которой карта не расширяет интерфейс Collections,
     заключается в том, что add(E e); не поддерживает пару ключевых значений, например Map put(K, V).
     # Зачем нам нужен дженерик в java?
     Generic биздин кодубуздун
     типизациясын кучойтот жана бизге
     туура эмес маалымат бергени жол
     бербейт.
     # Что мы можем облагородить?
     # Зачем нужны подстановочные знаки дженериков?
     Биз алмазный оператордун ичине бирден коп тип
     жазсак анда ошол типтитерди класстын же методтун
     ичинде колдонсок болот
     # Что такое анонимный класс?
     Б И Р Э Л Е Ж О Л У К О Л Д О Н О А Л А Т У Р Г А Н
     К Л А С С " А Н О Н И М Д У У К Л А С С " Д Е П А Т А Л А Т .
     Анонимдуу класстын конструктору болбойт.
     Метод тузсо болот бирок колдоно албайбыз.
     Анонимдуу класстын аты болбойт.
     Ар бир анонимдуу класстын тузулуусу уникалдуу.
     Объектиси тузулмойунчо анонимдуу класс
     тузулбойт.

     # Что такое функциональный интерфейс и зачем он нам нужен?
     Б И Р Э Л Е А Б С Т Р А К Т Т У У М Е Т О Д У Б А Р
     И Н Т Е Р Ф Е Й С " Ф У Н К Ц И О Н А Л Д У У " Д Е П
     А Т А Л А Т .
     Статик же дефолтный методтор эсепке кирбейт,
     башкысы бир гана абстракттуу методу болуусу керек.
     Функционалдуу интерфейстин устуно
     @FunctionalInterface аннотациясын койуу бул жакшы
     практика.
     Generic интерфейс да функционалдуу боло алат.

     # Что такое лямбда?
     Л Я М Б Д А Б У Л А Н О Н И М Д У У
     К Л А С С Т А Р Д Ы Н А Л Ь Т Е Р Н А Т И В А С Ы .
     Бул термин математикадан жана
     функционалдык программалоодон келип
     чыккан.
     Java 8 - версиясында чыккан жана бир гана
     функционалдуу интерфейстер менен
     иштейт.

     # Зачем нам Stream API?
     -Бул функционалдык стилдеги маалымат структуралары менен
     ишт??н?н жа?ы жолу.
     Stream (поток) API(бир компьютердик программанын экинчи
     программа менен иштеш??с?н?н жолдорун с?р?тт??) - негизи
     маалыматардын потогу.

     # Как работают потоки?
     Источник - иштетиле турган маалыматтар(List, Map, HashMap, ж.б)
     ?  Промежуточные операторы - маалыматтар боюнча иш-аракеттер, акыркы
     эмес, ж?н гана этап.
     ? Башка стрим кайтарат
     ? Иштет?? потокто алардын саны к?п болушу м?мк?н.
     ?  Терминальные (конечные) операторы –элементтерди иштетип, потокту
     бутуруп кандайдыр бир маанини кайтарып берет

     # Какие промежуточные операторы вы знаете?
     Оператор map
     Стримдеги элементтерди конвертацияга м?мк?нч?л?к берет (стримди
     кайра тузгону же анын маанилери озгортуп салганы).
     list.stream().map(x -> x * 2) // удвоить каждый
     элементlist.stream().map(x -> x.toLowerCase()); // перевести
     каждыйэлемент в нижний регистр
     Оператор map
     Map аркылуу, ар бир элемент боюнча маалыматты ?зг?рт??
     операциялары ж?рг?з?л?т.
     map () - промежуточный оператор, андан кийин башка промежуточный
     операторлор же терминалный оператор (мисалы, forEach) келет.

     Оператор берилген шарт боюнча элементерди фильтр кылат
     Промежуточный , ошондуктан стримде к?п жолу болушу м?мк?н.
     .filter(x -> x>3)
     3 т?н чо? элементтерди гана тандап жатабыз.
     Преобразование
     Любое изменение исходного элемента можно делать с помощью метода map(). В качестве параметра метод принимает лямбда-выражение.

     Stream.of(1, 2, 3, 4, 5, 6)
     .map(n -> n * 10) // умножает каждый элемент на 10
     Stream.of("apple", "orange")
     .map(String::toUpperCase) // преобразует буквы в каждом слове в верхний регистр
     Во втором случае мы воспользовались краткой записью лямбда-выражения через method reference.

     Фильтрация
     Отсеивание части объектов можно сделать с помощью метода filter().

     Stream.of(1, 2, 3, 4, 5, 6)
     .filter(n -> n > 3) // оставляет только те числа, которые больше 3
     Доступ к элементу
     Если требуется получить доступ к элементу, никак его при этом не меняя, нам поможет метод peek(). Например, в целях логирования мы хотим вывести значение элемента в консоль.

     Stream.of(1, 2, 3, 4, 5, 6)
     .peek(System.out::println)
     Удаление дублей
     Если в стриме несколько элементов имеют одинаковые значения, а вы хотите получить только уникальные, используйте метод distinct().

     Stream.of(2, 2, 3, 2, 3, 3, 2, 2)
     .distinct() // в результате останется только два элемента: [2, 3]
     Сортировка
     Для сортировки используйте метод sorted(). По умолчанию он использует «натуральный порядок», т.е. сортировку по возрастанию.

     Stream.of(2, 1, 3, 5, 4, 6)
     .sorted() // получим [1, 2, 3, 4, 5, 6]
     Перегруженная версия этого метода принимает интерфейс Comparator, поэтому вы можете задать свои собственные правила сортировки или воспользоваться готовыми. Приведённый выше пример равносилен следующему:

     Stream.of(2, 1, 3, 5, 4, 6)
     .sorted(Comparator.naturalOrder())) // получим [1, 2, 3, 4, 5, 6]
     Нетрудно догадаться, что обратную сортировку можно задать таким образом:

     Stream.of(2, 1, 3, 5, 4, 6)
     .sorted(Comparator.reverseOrder()) // получим [6, 5, 4, 3, 2, 1]
     Ограничение по количеству элементов
     Для получения первых N элементов используйте метод limit(). В данном случае мы берём первые 3 элемента:

     Stream.of(1, 2, 3, 4, 5, 6)
     .limit(3) // [1, 2, 3]
     Пропуск первых элементов
     Чтобы пропустить нужное количество первых элементов, используйте метод skip(). Здесь мы пропускаем первые 4 элемента и получаем оставшиеся два:

     Stream.of(1, 2, 3, 4, 5, 6)
     .skip(4) // [5, 6]
     Обратите внимание, что комбинация методов limit() и skip() позволяет организовать постраничный вывод информации. Например, в пользовательском интерфейсе мы отображаем по две записи на странице. Тогда, если у нас запросят вторую страницу, то выражение будет выглядеть так:

     Stream.of(1, 2, 3, 4, 5, 6)
     .skip(2)
     .limit(2) // [3, 4]
     Разворачивание многомерных структур
     Предположим, у вас есть многомерная структура (двумерный массив элементов типа Integer) и вы хотите его развернуть (сделать «плоским»), просто помещая каждый подмассив в конец результирующего. В этом нам поможет метод flatMap():

     Integer[][] array2d = new Integer[][]{{1, 2}, {3, 4}};
     Stream<Integer> stream =
     Arrays.stream(array2d).flatMap(Arrays::stream); // [1, 2, 3, 4]
     Выводы
     В этой статье мы рассмотрели на примерах промежуточные методы Stream API, а во второй части рассмотрим уже терминальные (конечные) методы.


     # Должны ли мы всегда использовать промежуточные операторы?
     # Можем ли мы создать поток без операторов терминала?
     # Можем ли мы использовать несколько операторов терминала в одном потоке?
     */